<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="index.css" />
    <style></style>
  </head>
  <body>
    <div class="mainContainer">
      <div class="requestsContainer">
        <div></div>
      </div>
      <form class="formContainer" name="options" novalidate>
        <div class="formRow">
          <div class="formElement">
            <select class="input" name="method" id="method">
              <option value="GET">GET</option>
              <option value="POST">POST</option>
              <option value="PUT">PUT</option>
            </select>
            <label class="label" for="method"> Метод </label>
          </div>
          <div class="formElement">
            <input class="input" name="url" />
            <label class="label"> URL </label>
          </div>
        </div>
        <button class="textButton">Добавить параметр</button>
        <button class="textButton">Добавить заголовок</button>
        <div class="buttonsContainer">
          <button class="actionButton">Сохранить запрос</button>
          <button class="actionButton">Отправить запрос</button>
          <button class="actionButton">Очистить форму</button>
        </div>
      </form>
    </div>

    <script async>
      const colors = [
        { label: "Green", id: "green" },
        { label: "Yellow", id: "yellow" },
        { label: "Blue", id: "blue" },
        { label: "Red", id: "red" },
        { label: "Pink", id: "pink" },
      ];

      function handleGetVariants() {
        fetch("/variants")
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error: ${response.status}`);
            }
            return response.json();
          })
          .then((json) => {
            for (let key in json) {
              if (json.hasOwnProperty(key)) {
                let val = json[key];
                let dataspan = `
                      <input type="radio" name="color" value=${val.id}>
                      ${val.label}
                      <span class="checkmark"></span>
                    `;
                const node = document.createElement("label");
                node.classList.add("button");
                node.classList.add(val.id);
                document
                  .getElementById("container")
                  .appendChild(node).innerHTML = dataspan;
              }
            }
          })
          .catch((err) => console.error(`Fetch problem: ${err.message}`));
      }

      function handleGetStat() {
        fetch("/stat", { method: "POST" })
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error: ${response.status}`);
            }

            return response.json();
          })
          .then((json) => {
            const colorsArr = Object.entries(json);
            for (let key in colorsArr) {
              const [color, count] = colorsArr[key];
              const dataspan = `
                      <span>${color}</span>:
                      <span>${count}</span>
                    `;
              const node = document.createElement("div");
              node.classList.add("stat");
              node.setAttribute("id", color);

              const oldEl = document.getElementById(color);
              if (oldEl) {
                document.getElementById("stat").removeChild(oldEl);
              }
              document.getElementById("stat").appendChild(node).innerHTML =
                dataspan;
            }
          })
          .catch((err) => console.error(`Fetch problem: ${err.message}`));
      }

      const formTag = document.forms.options;
      formTag.addEventListener("submit", handleSubmit, false);

      function handleSubmit(EO) {
        EO = EO || window.event;
        EO.preventDefault();
        const formTag = document.forms.options;
        const color = formTag.elements.color.value;

        const params = new URLSearchParams();
        params.append("color", color);

        fetch("/vote", { method: "POST", body: params })
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error: ${response.status}`);
            }
            handleGetStat();
          })
          .catch((err) => console.error(`Fetch problem: ${err.message}`));
      }

      function downloadResult(blobData, fileName) {
        const fakebtn = document.createElement("a");
        fakebtn.href = window.URL.createObjectURL(blobData);
        fakebtn.download = fileName;
        fakebtn.click();
      }

      async function call_for_json() {
        const fetchOptions = {
          method: "POST",
          headers: {
            Accept: "application/json",
          },
        };
        const response = await fetch("/stat", fetchOptions);

        const dataBlob = await response.blob();
        const blob = new Blob([dataBlob], {
          type: "application/json;charset=utf-8",
        });
        downloadResult(dataBlob, "result.json");
      }

      async function call_for_xml() {
        const fetchOptions = {
          method: "POST",
          headers: {
            Accept: "application/xml",
          },
        };
        const response = await fetch("/stat", fetchOptions);

        const dataBlob = await response.blob();
        const blob = new Blob([dataBlob], {
          type: "application/xml;charset=utf-8",
        });
        downloadResult(blob, "result.xml");

        const xmlStr = await response.text();
        const data = parseXml(xmlStr);
        console.log("получены данные в формате xml", data);
      }

      async function call_for_html() {
        const fetchOptions = {
          method: "POST",
          headers: {
            Accept: "text/html",
          },
        };
        const response = await fetch("/stat", fetchOptions);
        const data = await response.blob();
        const blob = new Blob([data], { type: "text/html;charset=utf-8" });
        downloadResult(blob, "result.html");
        console.log("получены данные в формате html", response);
      }

      function parseXml(xml, arrayTags) {
        var dom = null;
        if (window.DOMParser) {
          dom = new DOMParser().parseFromString(xml, "text/xml");
        } else if (window.ActiveXObject) {
          dom = new ActiveXObject("Microsoft.XMLDOM");
          dom.async = false;
          if (!dom.loadXML(xml)) {
            throw dom.parseError.reason + " " + dom.parseError.srcText;
          }
        } else {
          throw "cannot parse xml string!";
        }

        function isArray(o) {
          return Object.prototype.toString.apply(o) === "[object Array]";
        }

        function parseNode(xmlNode, result) {
          if (xmlNode.nodeName == "#text") {
            var v = xmlNode.nodeValue;
            if (v.trim()) {
              result["#text"] = v;
            }
            return;
          }

          var jsonNode = {};
          var existing = result[xmlNode.nodeName];
          if (existing) {
            if (!isArray(existing)) {
              result[xmlNode.nodeName] = [existing, jsonNode];
            } else {
              result[xmlNode.nodeName].push(jsonNode);
            }
          } else {
            if (arrayTags && arrayTags.indexOf(xmlNode.nodeName) != -1) {
              result[xmlNode.nodeName] = [jsonNode];
            } else {
              result[xmlNode.nodeName] = jsonNode;
            }
          }

          if (xmlNode.attributes) {
            var length = xmlNode.attributes.length;
            for (var i = 0; i < length; i++) {
              var attribute = xmlNode.attributes[i];
              jsonNode[attribute.nodeName] = attribute.nodeValue;
            }
          }

          var length = xmlNode.childNodes.length;
          for (var i = 0; i < length; i++) {
            parseNode(xmlNode.childNodes[i], jsonNode);
          }
        }

        var result = {};
        for (let i = 0; i < dom.childNodes.length; i++) {
          parseNode(dom.childNodes[i], result);
        }

        return result;
      }

      handleGetVariants();
      handleGetStat();
    </script>
  </body>
</html>
